/**
 * @file test_codegen_enum.c
 * @brief Unit tests for Enum code generation.
 *
 * Verifies correctness of `_to_str` and `_from_str` generation logic,
 * sentinel handling, and parameter validation safety. Includes tests
 * for guard configuration.
 *
 * @author Samuel Marks
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include <greatest.h>

#include "codegen.h"

/* Add definitions that need to be in the test runner's main file. */
GREATEST_MAIN_DEFS();

/**
 * @brief Verify logic generated by write_enum_to_str_func.
 * Checks that the output includes handling for members and UNKNOWN sentinel.
 */
TEST test_enum_to_str_generation(void) {
  FILE *tmp = tmpfile();
  struct EnumMembers em;
  long sz;
  char *content;

  ASSERT(tmp != NULL);
  em.size = 0;
  em.capacity = 4;
  em.members = malloc(sizeof(char *) * em.capacity);
  em.members[0] = "RED";
  em.members[1] = "GREEN";
  em.size = 2;

  ASSERT_EQ(0, write_enum_to_str_func(tmp, "Color", &em, NULL));

  fseek(tmp, 0, SEEK_END);
  sz = ftell(tmp);
  rewind(tmp);

  content = calloc(1, sz + 1);
  ASSERT(content != NULL);
  fread(content, 1, sz, tmp);

  /* Verify generated code structure */
  ASSERT(strstr(content,
                "int Color_to_str(enum Color val, char **str_out) {") != NULL);
  /* Check NULL safety check */
  ASSERT(strstr(content, "if (str_out == NULL) return EINVAL;") != NULL);
  /* Check Switch */
  ASSERT(strstr(content, "switch (val) {") != NULL);
  ASSERT(strstr(content, "case Color_RED:") != NULL);
  ASSERT(strstr(content, "case Color_GREEN:") != NULL);
  /* Check explicit UNKNOWN/default handling */
  ASSERT(strstr(content, "case Color_UNKNOWN:") != NULL);
  ASSERT(strstr(content, "default:") != NULL);
  ASSERT(strstr(content, "*str_out = strdup(\"UNKNOWN\");") != NULL);

  free(content);
  free(em.members);
  fclose(tmp);
  PASS();
}

/**
 * @brief Verify logic generated by write_enum_from_str_func.
 * Checks that the output includes string comparison logic and safe fallback.
 */
TEST test_enum_from_str_generation(void) {
  FILE *tmp = tmpfile();
  struct EnumMembers em;
  long sz;
  char *content;

  ASSERT(tmp != NULL);
  em.size = 0;
  em.capacity = 4;
  em.members = malloc(sizeof(char *) * em.capacity);
  em.members[0] = "RED";
  em.members[1] = "BLUE";
  em.size = 2;

  ASSERT_EQ(0, write_enum_from_str_func(tmp, "Color", &em, NULL));

  fseek(tmp, 0, SEEK_END);
  sz = ftell(tmp);
  rewind(tmp);

  content = calloc(1, sz + 1);
  ASSERT(content != NULL);
  fread(content, 1, sz, tmp);

  /* Verify generated code structure */
  ASSERT(
      strstr(content,
             "int Color_from_str(const char *const str, enum Color *val) {") !=
      NULL);
  /* Check input NULL checks */
  ASSERT(strstr(content, "if (val == NULL) return EINVAL;") != NULL);
  ASSERT(strstr(content, "else if (str == NULL) *val = Color_UNKNOWN;") !=
         NULL);

  /* Check comparison logic */
  ASSERT(strstr(content,
                "else if (strcmp(str, \"RED\") == 0) *val = Color_RED;") !=
         NULL);
  ASSERT(strstr(content,
                "else if (strcmp(str, \"BLUE\") == 0) *val = Color_BLUE;") !=
         NULL);

  /* Check final fallback to UNKNOWN */
  ASSERT(strstr(content, "else *val = Color_UNKNOWN;") != NULL);
  ASSERT(strstr(content, "return 0;") != NULL);

  free(content);
  free(em.members);
  fclose(tmp);
  PASS();
}

/**
 * @brief Verify that NULL arguments return strict EINVAL error codes.
 */
TEST test_enum_generation_null_safety(void) {
  FILE *tmp = tmpfile();
  struct EnumMembers em;
  em.size = 0;
  em.capacity = 0;
  em.members = NULL;

  ASSERT(tmp != NULL);

  /* Null File */
  ASSERT_EQ(EINVAL, write_enum_from_str_func(NULL, "E", &em, NULL));
  /* Null Name */
  ASSERT_EQ(EINVAL, write_enum_from_str_func(tmp, NULL, &em, NULL));
  /* Null Struct */
  ASSERT_EQ(EINVAL, write_enum_from_str_func(tmp, "E", NULL, NULL));

  fclose(tmp);
  PASS();
}

/**
 * @brief Verify that passing "UNKNOWN" as a member name does not duplicate
 * logic. Code generator should skip explicit handling of "UNKNOWN" in loop to
 * avoid conflict with default case.
 */
TEST test_enum_unknown_member_skipping(void) {
  FILE *tmp = tmpfile();
  struct EnumMembers em;
  long sz;
  char *content;

  ASSERT(tmp != NULL);
  em.size = 0;
  em.capacity = 4;
  em.members = malloc(sizeof(char *) * em.capacity);
  em.members[0] = "RED";
  em.members[1] = "UNKNOWN"; /* Provide strict UNKNOWN member */
  em.size = 2;

  ASSERT_EQ(0, write_enum_from_str_func(tmp, "Color", &em, NULL));

  fseek(tmp, 0, SEEK_END);
  sz = ftell(tmp);
  rewind(tmp);

  content = calloc(1, sz + 1);
  fread(content, 1, sz, tmp);

  /* Check that we DON'T generate an explicit strcmp for UNKNOWN in the loop */
  /* Because the final else handles it */
  ASSERT(strstr(content, "strcmp(str, \"UNKNOWN\")") == NULL);

  /* Ensure RED is logically there */
  ASSERT(strstr(content, "strcmp(str, \"RED\")") != NULL);

  /* Check final fallback exists */
  ASSERT(strstr(content, "else *val = Color_UNKNOWN;") != NULL);

  free(content);
  free(em.members);
  fclose(tmp);
  PASS();
}

/**
 * @brief Verify that providing a guard config wraps the functions in #ifdef.
 */
TEST test_enum_guard_generation(void) {
  FILE *tmp = tmpfile();
  struct EnumMembers em;
  struct CodegenConfig config;
  long sz;
  char *content;

  ASSERT(tmp != NULL);
  memset(&config, 0, sizeof(config));
  config.enum_guard = "TO_ENUM";

  em.size = 0;
  em.capacity = 4;
  em.members = malloc(sizeof(char *) * em.capacity);
  em.members[0] = "VALUE";
  em.size = 1;

  /* Helper to reset file for cleaner readback logic in single test func */
#define RESET_FILE(f)                                                          \
  do {                                                                         \
    rewind(f);                                                                 \
    if (ftruncate(fileno(f), 0)) {                                             \
    }                                                                          \
  } while (0)

  /* Test write_enum_to_str_func with guard */
  ASSERT_EQ(0, write_enum_to_str_func(tmp, "GuardedEnum", &em, &config));

  fseek(tmp, 0, SEEK_END);
  sz = ftell(tmp);
  rewind(tmp);
  content = calloc(1, sz + 1);
  fread(content, 1, sz, tmp);

  ASSERT(strstr(content, "#ifdef TO_ENUM") != NULL);
  ASSERT(strstr(content, "#endif /* TO_ENUM */") != NULL);
  ASSERT(strstr(content, "GuardedEnum_to_str") != NULL);

  free(content);

  /* Test write_enum_from_str_func with guard */
  freopen(NULL, "w+", tmp); /* Clear file */
  ASSERT_EQ(0, write_enum_from_str_func(tmp, "GuardedEnum", &em, &config));

  fseek(tmp, 0, SEEK_END);
  sz = ftell(tmp);
  rewind(tmp);
  content = calloc(1, sz + 1);
  fread(content, 1, sz, tmp);

  ASSERT(strstr(content, "#ifdef TO_ENUM") != NULL);
  ASSERT(strstr(content, "#endif /* TO_ENUM */") != NULL);
  ASSERT(strstr(content, "GuardedEnum_from_str") != NULL);

  free(content);
  free(em.members);
  fclose(tmp);
  PASS();
}

SUITE(codegen_enum_suite) {
  RUN_TEST(test_enum_to_str_generation);
  RUN_TEST(test_enum_from_str_generation);
  RUN_TEST(test_enum_generation_null_safety);
  RUN_TEST(test_enum_unknown_member_skipping);
  RUN_TEST(test_enum_guard_generation);
}

int main(int argc, char **argv) {
  GREATEST_MAIN_BEGIN();
  RUN_SUITE(codegen_enum_suite);
  GREATEST_MAIN_END();
}
