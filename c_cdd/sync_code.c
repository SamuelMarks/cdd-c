/**
 * @file sync_code.c
 * @brief Implementation of code synchronization command.
 *
 * Uses the C Inspector to parse headers and implementation files,
 * keeping helper functions and declarations in sync.
 *
 * @author Samuel Marks
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "c_inspector.h"
#include "codegen_enum.h"
#include "codegen_json.h"
#include "codegen_struct.h"
#include "codegen_types.h"
#include "fs.h"
#include "str_utils.h"
#include "sync_code.h"
#include "text_patcher.h"

int sync_code_main(int argc, char **argv) {
  const char *header_filename;
  const char *impl_filename;
  struct TypeDefList types;
  struct CodegenStructConfig struct_cfg = {0};
  struct CodegenJsonConfig json_cfg = {0};
  FILE *out = NULL;
  size_t i;
  int rc;

  if (argc != 2) {
    fprintf(stderr, "Usage: sync_code <header.h> <impl.c>\n");
    return EXIT_FAILURE;
  }

  header_filename = argv[0];
  impl_filename = argv[1];

  if ((rc = type_def_list_init(&types)) != 0)
    return rc;

  /* 1. Inspect Header */
  rc = c_inspector_scan_file_types(header_filename, &types);
  if (rc != 0) {
    type_def_list_free(&types);
    return rc;
  }

  /* 2. Open Output */
#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
  if (fopen_s(&out, impl_filename, "w") != 0)
    out = NULL;
#else
  out = fopen(impl_filename, "w");
#endif
  if (!out) {
    type_def_list_free(&types);
    return errno ? errno : EIO;
  }

  /* 3. Emit Preamble */
  fprintf(out, "/* Generated by sync_code */\n");
  fprintf(out,
          "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n");
  fprintf(out, "#include <parson.h>\n");
  {
    char *base = NULL;
    get_basename(header_filename, &base);
    if (base) {
      fprintf(out, "#include \"%s\"\n\n", base);
      free(base);
    }
  }

  /* 4. Emit Functions */
  for (i = 0; i < types.size; i++) {
    struct TypeDefinition *def = &types.items[i];

    if (def->kind == KIND_ENUM) {
      struct EnumMembers *em = def->details.enum_members;
      write_enum_to_str_func(out, def->name, em, NULL);
      write_enum_from_str_func(out, def->name, em, NULL);
    } else if (def->kind == KIND_STRUCT) {
      struct StructFields *sf = def->details.struct_fields;
      /* Emit Lifecycle */
      write_struct_cleanup_func(out, def->name, sf, &struct_cfg);
      write_struct_deepcopy_func(out, def->name, sf, &struct_cfg);
      write_struct_eq_func(out, def->name, sf, &struct_cfg);
      write_struct_default_func(out, def->name, sf, &struct_cfg);
      write_struct_debug_func(out, def->name, sf, &struct_cfg);

      /* Emit JSON */
      write_struct_to_json_func(out, def->name, sf, &json_cfg);
      write_struct_from_jsonObject_func(out, def->name, sf, &json_cfg);
      write_struct_from_json_func(out, def->name, &json_cfg);
    }
  }

  fclose(out);
  type_def_list_free(&types);
  printf("Synced %s\n", impl_filename);

  return 0;
}

int patch_header_from_source(const char *const header_path,
                             const char *const refactored_source) {
  struct FuncSigList sigs;
  struct PatchList patches;
  struct TokenList *hdr_tokens = NULL;
  char *hdr_content = NULL;
  char *new_header = NULL;
  size_t hdr_sz;
  size_t i;
  int rc;

  /* Init structures */
  rc = func_sig_list_init(&sigs);
  if (rc != 0)
    return rc;
  rc = patch_list_init(&patches);
  if (rc != 0) {
    func_sig_list_free(&sigs);
    return rc;
  }

  /* 1. Extract signatures from implementation source code */
  if ((rc = c_inspector_extract_signatures(refactored_source, &sigs)) != 0) {
    goto cleanup;
  }

  /* 2. Read and Tokenize Header */
  if ((rc = read_to_file(header_path, "r", &hdr_content, &hdr_sz)) != 0) {
    goto cleanup;
  }
  if ((rc = tokenize(az_span_create_from_str(hdr_content), &hdr_tokens)) != 0) {
    goto cleanup;
  }

  /* 3. Match signatures and build patches */
  /* Naive matching: Find IDENTIFIER "name" followed by LPAREN in header,
   * replace declaration */
  for (i = 0; i < sigs.size; ++i) {
    const char *func_name = sigs.items[i].name;
    size_t k;

    for (k = 0; k < hdr_tokens->size; ++k) {
      if (hdr_tokens->tokens[k].kind == TOKEN_IDENTIFIER &&
          token_matches_string(&hdr_tokens->tokens[k], func_name)) {

        /* Look ahead for LPAREN */
        size_t next = k + 1;
        while (next < hdr_tokens->size &&
               hdr_tokens->tokens[next].kind == TOKEN_WHITESPACE)
          next++;

        if (next < hdr_tokens->size &&
            hdr_tokens->tokens[next].kind == TOKEN_LPAREN) {
          /* Found function declaration. Find bounds. */
          /* Look behind for type (stop at semicolon/brace) */
          size_t start = k;
          size_t end;
          while (start > 0) {
            enum TokenKind pk = hdr_tokens->tokens[start - 1].kind;
            if (pk == TOKEN_SEMICOLON || pk == TOKEN_RBRACE ||
                pk == TOKEN_LBRACE)
              break;
            start--;
          }
          /* Look ahead for end of decl (SEMICOLON) */
          end = next;
          while (end < hdr_tokens->size) {
            if (hdr_tokens->tokens[end].kind == TOKEN_SEMICOLON)
              break;
            end++;
          }

          if (end < hdr_tokens->size) {
            /* Patch: Replace [start, end) with new signature */
            char *replacement;
#ifdef HAVE_ASPRINTF
            asprintf(&replacement, "%s", sigs.items[i].sig);
#else
            /* Simple fallback wrapper */
            replacement = c_cdd_strdup(sigs.items[i].sig);
#endif
            /* Note: signatures from extractor don't have semicolon, but we kept
             * semicolon token in Header */
            /* Actually extractor returns string without body. Header has
             * semicolon. */
            /* Our range [start, end) excludes the semicolon at 'end'. So we
             * effectively replace "void foo()" with "int foo()" and keep the
             * old semicolon. */

            patch_list_add(&patches, start, end, replacement);
          }
        }
      }
    }
  }

  /* 4. Apply Patches */
  if ((rc = patch_list_apply(&patches, hdr_tokens, &new_header)) != 0) {
    goto cleanup;
  }

  /* 5. Write Patch */
  if (new_header) {
    FILE *fp;
#if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
    if (fopen_s(&fp, header_path, "w") == 0 && fp) {
#else
    fp = fopen(header_path, "w");
    if (fp) {
#endif
      fputs(new_header, fp);
      fclose(fp);
    } else {
      rc = errno ? errno : EIO;
    }
  }

cleanup:
  func_sig_list_free(&sigs);
  patch_list_free(&patches);
  free_token_list(hdr_tokens);
  if (hdr_content)
    free(hdr_content);
  if (new_header)
    free(new_header);
  return rc;
}
